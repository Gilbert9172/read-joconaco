# Chap4. 에러

<br>
<br>

## Goal<!-- {"fold":true} -->

---

- 시스템이 복구할 수 있는 오류와 복구할 수 없는 **<span style="color:#FA5858">오류의 구분</span>**
- **<span style="color:#FA5858">신속</span>**<span>하게</span> 실패하고 **<span style="color:#FA5858">분명</span></span>**<span>하게</span>하게 실패함
- 오류를 전달하기 위한 **<span style="color:#FA5858">다양한 기법</span>**<span>과</span> **<span style="color:#FA5858">선택</span>**<span>을</span> 위한 고려사항

<br>
<br>

## 4.1 복구 가능성

---

> “자신의 코드가 어떻게 사용될지 정확히 알고 있어야한다.”

<br>

### ❐ 4.1.1 복구 가능한 오류

시스템 외부의 무언가에 의해 야기되는 오류에 대해서느 대부분 시스템 전체가 표나지 않고 적절하게<br>
처리하기 위해 노력해야 한다. 추상화 레벨이 높은 곳은 오류를 핸들링할 수 있는 정보가 적기 때문에,<br>
추상화 레벨이 낮은 곳에서 오류 처리하는게 좋다.

예를 들어 송금 서비스를 제공하는 A회사 서버에 이슈가 생긴다면, 해당 서비스를 사용하는 모든<br>
애플리케이션에 장애가 전파됩니다. 이런 경우 각 회사는 애플리케이션을 중단할게 아니고 적절한 조치가 필요합니다.

(길준)
될때 까지 애플리케이션 내부적으로 재요청 하는 resilence4j라는 라이브러리 중 [CircuitBreaker](https://resilience4j.readme.io/docs/circuitbreaker) 봐보시면 좋을 것 같습니다.

<br>
<br>

### ❐ 4.1.2 복구할 수 없는 오류

복구할 수 없는 오류는 흔히 프로그래밍 오류 때문에 발생할 때가 많다.
* 코드와 함께 추가되어야 하는 리소스가 없는 경우 (ex. 렌더링할 Html 파일 누락)
* A 함수에서 B 함수를 호출할 때 잘못된 파라미터 전달하는 경우
* NullPointException

이러한 오류가 발생했을 때 피해를 최소화하고, 개발자가 문제를 발견하고 문제를 해결하도록 해야한다.

<br>

### ❐ 4.1.3 호출하는 쪽에서만 오류 복구 가능 여부를 알 때가 많다.
> “오류 상황을 만났을 때, 이를 복구해야 할 책임이 어디에 있는가?”

오류가 발생했을 때 이를 복구할 책임이 호출자 쪽에 있는지, 아니면 호출당 당한 코드에 있는지를 잘 파악할 수 있어야 한다.


**오류 복구의 책임 위치**<br>
코드를 작성하거나 수정할 때마다 오류 복구가 가능할지, 또는 복구를 해야 하는지 항상 알 수 있는 것은 아니다.<br> 
오류 복구는 코드가 호출되는 방식이나 현재 맥락에 따라 달라질 수 있으며, 모든 호출자가 같은 방식으로 오류를 <br>
처리하기를 기대하기 어렵다.

**호출자의 복구 필요성**<br>
오류 발생 시 호출자(함수를 호출한 코드) 쪽에서 오류 복구가 필요한지 먼저 생각해야 한다.<br>
예를 들어, 네트워크 요청을 보냈는데 응답을 못 받았다면, 호출자가 재시도를 원할 수도 있다.<br>

**에러 처리의 신호**<br>
호출자가 오류를 처리해야 한다면, 호출자가 그 오류가 발생했음을 쉽게 알 수 있어야 한다.<br>
예를 들어, 예외를 던져 호출자가 그 예외를 포착하도록 하거나, 메서드 반환값을 통해 오류 발생을 알려야 한다.

**간결한 추상화 유지**<br>
오류 처리를 포함한 코드의 추상화는 호출자가 코드 내부의 오류 처리 방식을 지나치게 알아야 할 필요가 없도록<br>
하는 것이 좋다. 특정 상황에서 발생할 수 있는 오류에 대해 호출자가 너무 많은 것을 알게 하면 재사용성에 방해가<br>
되기 때문이다.

<br>
<br>

### ❐ 4.1.3 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라
> “오류가 발생했을 때 호출한 쪽에서 그 오류를 알 수 있도록 해라”

내가 작성한 코드를 호출하는 곳이, 내 의도대로 호출할 거라고 생각하면 안된다.<br>
상황에 맞는 상태 코드 또는 메시지를 호출하는 쪽에게 알려줘야 한다.

<br>
<br>
<br>

## 4.2 견고성 vs 실패

---

> **견고한 코드란?** 오류를 처리하고 계속 진행하는 코드

<br>

### 4.2.1 신속하게 실패하라 (Failing Fast)

Failing Fast는 가능한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내는 것이다.<br>
이번 장에서는 Early return을 강조하는 것 같습니다. 저희가 프리코스 하면서 메소드 앞 단에<br>
validation 로직을 작성하는 것과 동일한 부분입니다.

예를 들어 10보다 작은 수들만 입력해서 그 합을 구하는 경우 Failing Fast한 코드와 그렇지 않은
코드는 다음과 같을 것입니다.
```java
// Failing Slow
public void addl(final List<Integer> numbers) {
	int answer = 0;
	for (int num : numbers) {
		anwer += num;
		if (num > 5) throw new Exception("error message");
	}
}
```

```java
// Failing Fast
public void add(final List<Integer> numbers) {
	int answer = 0;
	for (int num : numbers) {
		if (num > 5) throw new Exception("error message");
		anwer += num;
	}
}
```

Failing Fast한 코드를 작성해야 하는 이유는 오류가 실제 위치보다 먼 곳에서 터지게 되면 stackTrace에<br> 
그만큼 많이 정보들이 쌓일 것이고 이를 트랙킹하는 것은 여러 리소스(시간, 체력)를 낭비하기 때문입니다.<br> 
또한 예상하지 못한 DB commit이 발생하게 되면 해당 데이터의 정확성이 깨지기 때문입니다.

<br>
<br>

### 4.2.2 요란하게 실패하라
> 오류가 발생하는데도 불구하고 아무도 모르는 상황을 막고기 위해서 요란하게 실패하라.

명확하게 어떤 오류가 발생했는지 누구나 다 인지할 수 있도록 하라는 것을 의미하는 것 같습니다.<br>
예를 들어 DB 커넥션 정보를 제대로 입력하지 않은 상태에서 Spring Boot 서버를 구동하려고 할 때<br>

<img src="static/image/failing_db_connection.png" width="80%" height="80%"></img>

위와 같이 오류 메시지를 출력하고 프로그램을 중단하는 경우라고 생각합니다.

<br>
<br>

### 4.2.3 복구 가능성의 범위

> 복구할 수 있는 또는 복구할 수 없는 범위는 달라질 수 있다.

서버가 클라이언트의 요청을 처리하는 과정에서, 코드에 버그가 있어서 특정 요청 처리 중에 오류가 발생할 수 있다.<br> 
이때 해당 요청을 처리하는 범위 내에서 복구할 수 있는 합리적인 방법은 없지만, try-catch 등을 통해 시스템 전체가<br> 
작동을 멈추는 것은 막을 수 있다. (관련 페이지 88)

```java
// 요청 들어옴
try {
    // 요청을 처리하는 로직
    // 에러 발생	
} catch (Exception e) {
    // 서버 전체가 동작을 멈추지 않도록 예외 발생 
    // 오류 상태 반환
    // logging
    // 외부 서비스(slack, github, aws 등등)와 연동 
}
```

<br>
<br>

### 4.2.4 오류를 숨기지 않음
> “오류를 숨지기 말고 명확히 드러내야 한다.”

오류를 숨기게 되면 호출하는 쪽에서 복구할 기회를 놓치게 되고, 복구할 수 없는 오류의 경우도<br>
문제를 인지하지 못해 시스템이 불안정해질 수 있다.

해당 챕터를 요약해보자면,
- 오류 발생 시 숨기지 않고 명확히 드러내야 소프트웨어가 의도한 대로 작동하지 않는 상황을 방지할 수 있다.
- 호출자가 오류를 복구할 수 있어야 하므로, 오류를 숨기면 복구할 기회가 사라진다. 
  - (추후 버그로 이어질 확률이 높음)
- 오류를 숨기면 개발팀이 문제를 인지하지 못해, 버그가 오랫동안 방치될 수 있다.

결과적으로 잘못된 데이터나 시스템 장애를 유발할 수 있습니다.

```text
(길준) 
저는 개인적으로 빈번하게 발생하지 않는 오류에 대한 수정을 개발 일정 상 뒤로 미루는 것도 오류를 
숨기는 것이라고 생각합니다. 계속 뒤로 밀리다보면 책에서 언급된 것 처럼 예상치 못한 데이터가 
들어올 수 있기 때문입니다. 그리고 개발자라면 오류를 무시하는 습관을 들이는 것이 치명적이라고 생각합니다!
```

<br>

#### 오류를 숨기는 방법들

**1. 기본 값 반환**<br>
코드에 기본값을 두는 것이 유용한 경우가 있을 수 있지만, 오류를 처리할 때는 대부분의 경우<br>
적합하지 않다. 잘못된 데이터로 시스템이 제대로 작동하지 못하게 만들고 오류가 나중에 이상한<br>
방식으로 날 수 있기 때문이다.

저번 과제에서 저도 이 부분을 사용했었는데요. 참고해보시면 좋을 것 같습니다. ( [관련 링크](https://github.com/woowacourse-precourse/java-calculator-7/pull/27#discussion_r1810655263))
<img src="static/image/return_primitive.png" width="80%" height="80%"></img>

<br>

**2. Null 객체 패턴**
Null 객체는 개념적으로 기본값과 유사하지만 이것을 더 확장해서 더 복잡한 객체를 다룬다.<br>
Null 객체는 실제 반환 값 처럼 보이지만 모든 멤버 함수는 아무것도 하지 않거나 의미 없는<br>
기본 값을 반환한다. 이 부분은 6장에서 더 자세히 다룬다고 합니다.

<br>

**3. 아무것도 하지 않음**

- 진짜 아무것도 하지 않음
    ```java
    public void example(int value) {
        if (value == 0) {
            return;
        }
        this.value = value;
    }
    ```

- 예외 억제
    ```java
    try {
        // 이메일 전송 
    } catch (Exception e) {
        // Do nothing 
    }
    ```

- 예외 탐지 및 오류 기록 <span style="color:red">(이 부분에서는 개인 정보가 로깅될 수 있기 때문에 주의해야 한다.)</span>
    ```java
    try {
        // 이메일 전송 
    } catch (Exception e) {
        logger.logError(e) // 개인정보가 로깅에 대한 정책 확립 필요 
    }
    ```

<br>
<br>

## ❐ 4.3 오류 전달 방법

---

오류 전달 방법에는 명시적, 암시적 방법이 있다.

<img src="static/image/explicit_implicit.png" width="80%" height="80%"></img>


**명시적 전달 방법**
- 오류가 발생했을 때 이를 호출자가 정확히 인지할 수 있게 전달하는 방식
- 이를 처리하는 건 호출자에게 달려있음

**암시적 전달 방법**
- 오류가 발생해도 호출자가 이를 바로 인지하지 못하고, 무시되거나 넘어가는 방식
- (길준) 4.2.4에서 읽은 “아무것도 하지 않기”가 비슷한 맥락 같다고 생각됩니다.

<br>

### 4.3.1 요약: 예외
간단히 요약하면 자바 이외의 거의 모든 언어는 unchecked exception만 다루기 때문에<br>
예외라는 용어는 일반적으로 unchecked exception을 말한다.

<br>

### 4.3.2 명시적 방법 : Checked Exception

#### 1. checked exception을 사용한 오류 전달
checked exception은 오류를 전달하기 위한 명시적인 방법이다.
```java
public class CustomException extends Exception {...}
```

#### 2. checked exception 처리<!-- {"fold":true} -->
```java
void sampleMethod() {
	try {
		// 로직 수행
		// 에러 발생
	} catch (CustomException e) {
		// 적절히 처리
	}
}
```

```java
void sampleMethod() throws CustomException {
	// 로직 수행
}
```

<br>

### 4.3.3 암시적 방법 : unchecked exception

#### 1. unchecked exception을 사용한 오류 전달<!-- {"fold":true} -->
```java
public class CustomException extends RuntimeException {...}
```

#### 2. unchecked exception 처리
```java
void sampleMethod() {
	try {
		// 로직 수행
		// 에러 발생
	} catch (CustomException e) {
		// 적절히 처리
	}
}
```

```java
void sampleMethod() throws CustomException {
	// 로직 수행
}
```

<br>

### 4.3.4 명시적 방법 : Null 값이 가능한 반환 유형
> Null 값이 가능한 반환 유형을 사용하는 것은 오류를 전달하기 위한 명시적인 방법이다.

```java
public void view() {
	int value = Console.readLine();
	if (sampleMethod(value) == null) {
		//...
	};
}

public String sampleMethod(int value) {
	if (value < 0) return null; // null 반환
	return "hello";
}
```

(길준)
그러나 이렇게 null로 넘겨주기 보단 아래와 같이 넘겨주는 것이 더 괜찮을 것 같습니다.
```java
public Orders sampleMethod(MemberId id) {
    //...
    return Orders.empty(); 
}
```
이렇게 생각한 이유는 Java Collections에서도 Collections.emptyList();와 같은 메서드가<br>
있는데요 이는 코드의 가독성을 높여주어 좀 더 readable한 코드를 만들 수 있다고 생각합니다.<br>
또한 Optional에서도 empty() 메소드를 확인할 수 있습니다. 이건 개인적인 의견이지만 Java <br>
환경에서 개발을 하는 경우에는 기존 자바 코드와의 일관성을 가져가는게 좋다고 생각합니다!<br>
의견 있다면 알려주세요!

<br>

### 4.3.5 명시적 방법 : Result<V,E>
> 호출자에게 값을 얻을 수 없는 이유까지 알려줄 때

자바에서는 지원하지 않는 함수다. 따라서 별도로 구현해야 한다. (자세한 내용은 pg 100 ~ 102 참고)

(길준) 
보통 Spring Boot를 사용해서 개발할 때 아래와 같이 에러 메세지, 헤더, 상태 코드 등의 데이터를<br> 
응답하는데 이번 챕터는 이런 이야기를 하는 것 같습니다.

<img src="static/image/response_message.png" width="80%" height="80%"></img>

<br>

### 4.3.6 명시적 방법 : 아웃컴 반환 유형<!-- {"fold":true} -->
아웃컴(Outcome) 반환 유형은 메서드나 함수가 성공 또는 실패 여부와 함께 성공 시 결과값,<br>
실패 시 오류 정보를 함께 반환하는 방식을 의미한다. 이 접근법은 명시적으로 성공과 실패를 구분할 수 있어,<br>
호출자가 함수의 실행 결과를 더 명확히 인지하고 처리할 수 있다.

```java
public boolean sampleMethod(int value) {
	if (value > 0) {
		return true;
	}
	return false;
}
```

아웃컴 반환 유형에 대한 문제점 중 하나는 호출하는 쪽에서 반환 값을 무시하거나 함수가 값을<br>
반환한다는 사실조차 인식 못할 수 있다는 점이다. 이로 인해 아웃컴 반환 유형은 오류를 알리는<br>
명시적 방법으로 한계가 있다.

<br> 

### 4.3.7 암시적 방법: 프로미스 또는 퓨처
> 읽어보기만 하고 넘어가도 될 것 같습니다. 따라서 Pass

<br> 

### 4.3.8 암시적 방법: 매직값 반환
> 오류를 알리는 좋은 방법이 아님. 따라서 Pass

매직값은 코드 계약의 명백한 부분을 통해 호출하는 쪽에 알릴 수 없어서 예상을 벗아나는 결과를<br>
가져올 수 있다. 따라서 좋은 방법이 아니다. 

<br>
<br> 

## ❐ 4.4 복구할 수 없는 오류의 전달

---

현실적으로 복구할 가능성이 없는 오류가 발생하면 신속하게 실패하고, 요란하게 실패하는 것이 최상의 방법이다.

<br>
<br> 

## ❐ 4.5 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달<!-- {"fold":true} -->

---

> 오류 전달의 모범 답안은? 이라는 주제로 많은 주장과 반론을 정리한 챕터
<br>
> 제대로 된 코드리뷰가 정착하지 않은 경우에는 어느 경우라도 문제가 생김.

<br>

### 4.5.1 Unchecked Exception을 사용해야 한다는 주장
> 핵심 장점은 오류를 처리하는 로직이 코드 전체에 퍼지지 않는다.

이 방법을 사용하면 대부분의 오류 처리가 코드의 상위 계층에서 이루어질 수 있기 때문에<br>
unchecked exception을 발생시키면 코드 구조를 개선할 수 있다고 주장하는 개발자들이 있다.

```text
(길준) 
여기서 말하는 “코드 구조 개선”이란, try-catch가 프로젝트에서 많이 덜어냈는냐 인거 같은데
 다른 의견있다면 남겨주시면 좋을 것 같습니다~
```

<br>

### 4.5.2 명시적 기법을 사용해야 한다는 주장

- 명시적으로 예외 처리를 하면 코드 검수할 때 쉽게 눈에 띈다.
- 명시적 예외는 개발자가 실수로 예외를 무시할 수 없다.
- 비검사 예외는 특정 입력 필드에서 오류가 발생하더라도 UI에서 사용자에게
  알맞은 피드백을 주기 어렵다.
- 비검사 예외가 코드베이스 전반에 결쳐 제대로 문서화된다는 보장이 없다.
- 비검사 예외는 두더지 잡기하는 게임 같다.

<br>

### 4.5.3 필자의 의견 : 명시적 방식을 사용해라
**호출하는 쪽에서 복구하기를 원할 수도 있는 오류**에 대해 unchecked exception을 사용하지 않는 것이<br>
최상이라는 것이 필자의 의견이다. 필자의 경험상 비검사 예외의 사용은 코드베이스 전반에 걸쳐 문서화<br>
되는 경우가 매우 드물며, 이것이 의미하는 바는 해당 함수에 대해 발생 가능한 오류와 이에 대한 처리를<br>
어떻게 해야 하는지 개발자가 확실하게 알기란 거의 불가능하다는 것이다.


```text
(길준) 
저는 개인적으로 아래와 같은 의견입니다. 기본적으로는 팀 컨벤션에 적용된 기법 사용하는게 맞다고 생각합니다.

하지만 딱히 정해져 있지 않다면,

1. 프로젝트 규모 크다
명시적 기법을 사용, 기존에 Unchecked Exception을 사용했다면 리팩토링 진행 

2. 회사 규모 작다. (팀내 개발자 3~4명)
Unchecked Exception을 사용, 빠른 스프린트 단위의 생산성을 위함. 
```

<br>
<br>

## 4.6 컴파일러 경고를 무시하지 말라<!-- {"fold":true} -->

---

컴파일이 되기 때문에 치명적인 문제는 없다고 가정하기 쉽지만, 경거는 단지 경고일 뿐이지만,<br>
종종 코드에 문제가 있다는 신호일 수 있으며, 어떤 상황에서는 심각한  버그가 될 수 있다.<br>
모든 이슈는 수정되었거나 정당한 이유가 있는 경우 유효한 설명과 함께 명시적으로 억제하기<br>
때문에(= 처리되기 때문에) 코드를 컴파일할 때 경고가 없는 것이 이상적이다.


(길준)

책에 색깔이 알록달록 하지 않아서 예제는 제가 만들어봤습니다.<br>
private 멤머 name을 읽는 경우가 전현 없다는 컴파일 에러입니다.
<img src="static/image/do_not_ignore_compile_warning_1.png" width="80%" height="80%"></img>

다음은 `@SuppressWarnings("all")`을 사용해서 해당 경고를 무시할 수도 있긴 합니다.<br>
<img src="static/image/do_not_ignore_compile_warning_2.png" width="80%" height="80%"></img>

이렇게 하고 커밋하려고 하면 이렇게 warning이 뜹니다.<br>
<img src="static/image/do_not_ignore_compile_warning_3.png" width="80%" height="80%"></img><br>

```text
이 상태로 커밋하면 warning이 많아져서 저는 무조건 다 없애고 커밋하는데 여러분은 어떤가요?
의견1) 애플리케이션에 영향을 미치지 않는 warning이라면 pass
의견2) warning 모두 제거하기
```

<br>

그리고 아래는 [이펙티브 자바 Item27. 비검사 경고를 제거하라](https://github.com/GunterMueller/Books-3/blob/master/Effective%20Java%20%283rd%20Edition%29.pdf) 에 언급된 내용입니다.<br>
비슷한 내용이라 같이 보면 나쁘지 않을 것 같아서 언급해봤습니다!
```text
비검사 경고는 중요하니 무시하지 말자!
모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 가능성을 뜻하니 
최선을 다해 제거하라. 경고를 없앨 방법을 찾지 못하겠다면, 그 코드가 타입 안전함을 증명하고 
가능한 한 범위를 좁혀 @SuppressWarnings("unchecked")로 경고를 숨겨라. 그런 다음 경고를 
숨기기로 한 근거를 주석으로 남겨라
```


<br>
<br>