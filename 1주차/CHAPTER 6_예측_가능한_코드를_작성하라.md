# CHAPTER 6 예측 가능한 코드를 작성하라 40

- 코드가 예기치 못한 일을 하거나 예상하지 못한 것을 반환하면 다른 개발자들이 혼란을 겪을 수 있고, 이로 인해 버그가 일어날 수 있다.

코드를 작성할 때 그 코드는 훨씬 더 큰 코드베이스의 일부일 뿐이다.

우리는 다른 개발자가 작성한 코드에 **기반해서** 코드를 작성하고, 다른 개발자들은 다시 우리가 작성한 코드에 기반해서 자신의 코드를 작성한다.

이를 위해 개발자는 코드가 무엇을 하고, 어떻게 사용해야 하는지 이해해야 한다.

예측 가능한 코드를 작성하는 것은 무엇을 분명하게 하는 것일 때가 많다.

함수가 아무것도 반환하지 않을 때가 있거나 처리해야 할 특별한 시나리오가 있는 경우 이 사실을 다른 개발자에게 확실히 알려야 한다.

그렇지 않으면 코드의 동작이 그들이 실제 얻어낼 것이라 생각하는 것과 일치하지 않을 위험이 있다.

## 6.1 매직 값을 반환하지 말아야 한다

매직값(magic value)은 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 가지고 있다.

매직값의 일반적인 예는 값이 없거나 오류가 발생했음을 나타내기 위해 -1을 반환하는 것이다.

매직값은 함수의 정상적인 반환 유형에 들어맞기 때문에 이 값이 갖는 특별한 의미를 인지하지 못하고, 이에 대해 적극적으로 경계하지 않으면 정상적인 반환값으로 오인하기 쉽다.

### 6.1.1 매직 값이 버그를 유발할 수 있다

- 매직 값(Magic Value)은 정상적인 반환 값이지만 특별한 의미를 가지는 값으로, 일반적으로 오류나 값이 없음을 나타내기 위해 -1과 같은 특정 숫자를 반환하는 경우를 말한다.
- 이러한 매직 값은 반환된 값을 정상적인 값으로 오해하게 하여 예측하지 못한 버그를 유발할 수 있다.

#### 예제

1. `User` 클래스의 `getAge()` 메서드가 매직 값 `-1`을 반환하여 사용자가 나이가 없음을 표시한다고 가정.
2. 사용자의 평균 나이를 계산하는 `getMeanAge()` 메서드에서는 `-1`을 정상적인 나이로 간주해 평균에 포함할 수 있으며, 이는 잘못된 평균을 초래할 가능성이 있다.

### 6.1.2 해결책: Null, Optional, 또는 오류 반환 사용

- 매직 값 대신 **null**, **Optional**, 또는 **에러 전송**을 통해 값을 반환하도록 한다.

- 예를 들어, Java에서는 값이 없을 때 `Optional<T>` 타입을 반환함으로써 호출자가 값이 없을 가능성을 인식하게 할 수 있다.

- 대체로 널이 가능한 반환 유형을 호출하는 쪽에 '널 가능성을 인지하고 처리하는 코드가 추가로 필요'하므로 부담을 준다. 아래와 같은 반대하는 **이유들**과 그에 대한 방안이다.

  - **버그 위험**
    - 값이 존재하지 않을 가능성을 함수가 명확히 알리지 않으면, 호출 측에서는 이를 예측하지 못하고 버그를 초래할 수 있다. 잠재적으로 이러한 버그를 고치는 데 들어가는 비용과 노력이 널 반환 처리를 위해 코드에 추가하는 비용보다 높을 수 있다.
  - **널 객체 패턴의 활용 가능성**
    - 널 객체 패턴(Null Object Pattern)을 이용해 널 대신 특정 상황에서 값을 의미하는 객체를 반환하는 방법도 있지만, 이 방식 역시 적절하지 않게 사용될 경우 문제를 일으킬 수 있다.
  - **널로 인한 예외 발생 위험**
    - 널 값 반환은 **NullPointerException**이나 **NullReferenceException**을 유발할 수 있는 위험이 존재한다. 하지만 널 안전성을 지원하거나 **Optional**을 사용하면 이러한 예외의 가능성을 크게 줄일 수 있다.

### 6.1.3 매직 값의 의도치 않은 발생 가능성

- 매직 값은 개발자가 의도하지 않았더라도 특정 상황에서 우연히 발생할 수 있다.

- 예를 들어, 리스트가 비어 있을 때 최소값을 찾는 함수가 `Integer.MAX_VALUE`를 반환하는 경우.

#### 해결책: Null 반환 또는 오류 전송

- 매직 값 대신, 리스트가 비어 있으면 **null**을 반환하거나 예외 처리를 사용한다.
- 호출하는 쪽에서는 빈 리스트에 대해 잘못된 결과를 받지 않게 된다.

## 6.2 널 객체 패턴을 적절히 사용하라

값을 얻을 수 없을 때 널값이나 빈 옵션을 반환하는 대신 널 객체 패턴을 사용할 수 있다.

널 객체 패턴을 사용하는 이유는 널값을 반환하는 대신 유효한 값이 반환되어 그 이후에 실행되는 로직에서 널값으로 인해 시스템에 피해가 가지 않도록 하기 위함이다.

이것의 가장 간단한 형태는 빈 **문자열**이나 빈 리스트를 반환하는 것이지만, 더 정교한 형태로는 모든 멤버 함수가 아무것도 하지 않거나 기본값을 반환하는 클래스를 구현하는 것이 있다.

널 안전성을 지원하지 않는 언어를 사용하고 있다면 널 대신 옵션서를 반환하면 된다.

### 6.2.1 빈 컬렉션 반환의 장점

- **문제점**: 컬렉션을 반환할 때 널을 반환하면 호출하는 코드에서 매번 널 체크를 해야 한다. 널 체크가 누락되면 널 포인터 예외가 발생해 프로그램의 안정성을 저하시킬 수 있다.

- **해결책**: 빈 컬렉션을 반환하면 **호출자**가 널을 체크할 필요 없이 안전하게 코드를 작성할 수 있다. 호출자는 반환된 컬렉션이 항상 컬렉션 타입으로 **제공됨을** 보장받기 때문에 널 체크 코드가 필요 없어지다.

- **예시**: `getClassNames(HtmlElement element)` 함수는 클래스 속성이 없을 경우 널이 아닌 빈 집합을 반환하도록 수정한다. 이 경우 `isElementHighlighted()`에서 `getClassNames()`가 반환하는 값에 대해 널 체크 없이 안전하게 처리할 수 있다.

> [널 포인트 예외]  
> 널 객체 패턴의 사용을 지지하는 오래된 의견은 **NullPointerException**과 같은 예외를 발생시킬 가능성을 최소화해야 한다는 주장이다.

널 안전성을 지원하지 않는 언어를 사용할 경우 호출하는 쪽에서는 값을 사용하기 전에 널 여부를 확인하지 않을 수 없기 때문에 널을 반환하는 것은 항상 위험을 수반한다.

널 안전성이 옵션서(널 안전성이 지원되지 않는 경우)를 사용하는 한, 이 주장은 더 이상 의미가 없다.

하지만 널 안전성이 없는 **레거시** 코드베이스에서는 여전히 의미 있는 주장이다.

### 6.2.2 빈 문자열 반환의 적절성과 한계

- **단순 문자열**: 문자열이 단순히 문자열의 집합인 경우 널 대신 빈 문자열을 반환해도 문제가 없다. 이는 호출자가 널을 고려할 필요 없이 결과를 바로 사용할 수 있도록 한다.

- **의미 있는 문자열(ID 등)**: 문자열이 특정 의미를 가질 때, 빈 문자열은 혼란을 야기할 수 있다. 예를 들어 `getCardTransactionId()`에서 카드 거래와 관련 없는 경우 빈 문자열 대신 널을 반환하면, 호출 측에서 명확하게 “이 결제가 카드 거래가 아님”을 인식할 수 있다.

### 6.2.3 복잡한 널 객체는 예측을 벗어날 수 있음

- **문제점**: 널 객체를 사용할 때 호출 측에서 불필요한 오해를 일으킬 수 있습니다. 예를 들어, `getRandomMug()` 함수가 재고가 없을 때 크기 0의 빈 머그 객체를 반환하면 호출자는 이를 유효한 머그 객체로 오해할 가능성이 있다.

- **해결책**: 재고가 없을 때 널을 반환하여 호출자가 재고가 없음을 인식하도록 하는 것이 더 명확한 방법이 될 수 있다.

### 6.2.4 널 객체 구현의 예측 불가능성

- **널 객체 전용 클래스 문제**: `NullCoffeeMug`와 같은 널 객체 전용 클래스를 구현하여 반환할 수도 있다. 하지만 호출자가 이 객체가 널 객체임을 인지하지 못하면, 여전히 혼란을 일으킬 수 있다. 예를 들어, `getRandomMug()`가 `NullCoffeeMug`를 반환할 때, 호출 측에서는 이 객체를 일반 커피 **머그로 오인하여** 잘못 사용할 가능성이 있다.

- **널 확인의 복잡성**: 널 객체 클래스를 확인하는 것은 널 체크보다 복잡하고 오히려 코드의 가독성을 떨어뜨릴 수 있다.

## 6.3 예기치 않은 부수 효과를 피하라

부수 효과(side effect)는 어떤 함수의 호출이 함수 외부에 초래한 상태 변화를 의미한다.

함수가 반환하는 값 외에 다른 효과가 있다면 이는 부수 효과가 있는 것이다.

일반적인 부수 효과 유형은 다음과 같다.

- 사용자에게 출력 표시
- 파일이나 데이터베이스에 무언가를 저장
- 다른 시스템을 호출하여 네트워크 트래픽 발생
- 캐시 업데이트 혹은 무효화

부수 효과는 소프트웨어 작성 시 불가피하며 부수 효과가 없는 소프트웨어에는 무의미할 것이다.

부수 효과가 예상되고 코드를 호출한 쪽에서 그것을 원한다면 괜찮지만, 부수 효과가 예상되지 않을 경우 버그로 이어질 수 있다.

예상치 못한 부수 효과를 일으키는 것을 피하는 좋은 방법 중 하나는 애초에 부수 효과가 일어나지 않도록 하는 것이다.

부수 효과가 원하는 기능의 **일부거나** 피할 수 없는 경우에는 호출하는 쪽에서 이에 대해 확실하게 인지하도록 하는 것이 중요하다.

### 6.3.1 명확하고 의도적인 부수 효과는 괜찮다

- **부수 효과의 필요성**: 코드의 일부에는 의도적인 부수 효과가 필요한 경우가 있다. 예를 들어, `UserDisplay` 클래스의 `displayErrorMessage()` 함수는 오류 메시지를 사용자에게 보여주기 위해 업데이트한다.

- **명확성의 중요성**: `displayErrorMessage()`와 같은 명확한 함수명은 부수 효과가 발생할 것을 호출자가 예상하게 하므로, 코드의 예측 가능성을 높인다. 호출자는 캔버스가 변경될 것임을 쉽게 이해할 수 있다.

### 6.3.2 예기치 않은 부수 효과의 문제

- **부수 효과 문제**: 함수가 단순히 값을 얻기 위해 호출될 경우, 다른 개발자는 일반적으로 해당 함수가 부수 효과를 발생시키지 않는다고 가정한다.

- **예제 (예제 6.19)**: `getPixel(int x, int y)` 함수는 픽셀 색상을 가져오기 전에 `canvas.redraw()`를 호출해 캔버스를 다시 그린다. 이는 부수 효과를 발생시키며, 사용자가 예상하지 못할 수 있다.

- **비용 문제(성능문제)**: `canvas.redraw()`는 비용이 많이 들 수 있어, `getPixel()`을 반복적으로 호출할 때 성능 저하 및 깜빡임 현상이 발생할 수 있다.

- **다중 스레드 환경에서 부수 효과의 문제**
  - **다중 스레드 문제**: 다중 스레드 환경에서 `getPixel()`이나 `captureScreenshot()`을 동시에 호출하면, 부수 효과로 인해 캔버스 데이터가 잘못 일치를 수 있다.
  - **문제 발생 시 디버깅 어려움**: 다중 스레드 문제는 **디버깅**과 테스트가 어렵기 때문에 부수 효과로 인해 예기치 못한 동작이 발생할 가능성이 있다.

### 6.3.3 해결책: 부수 효과를 피하거나 명확하게 알리기

1. **부수 효과 피하기**: 예측 가능한 코드를 작성하려면 부수 효과를 피하는 것이 가장 좋다. 불필요한 `canvas.redraw()` 호출을 제거하여 문제 지점을 없애야 한다.

2. **명확한 함수명 사용**: 부수 효과가 발생하는 경우, 함수명을 `redrawAndGetPixel()`처럼 명확하게 바꾸어 부수 효과가 발생함을 나타낸다.

## 6.4 입력 매개 변수를 수정하는 것에 주의하라

함수 내에서 입력 **매개변수**를 수정하는 것 또한 부수 효과가 발생한다.

이것은 예상을 벗어나는 코드 및 버그의 혼란 원인이 될 수 있다.

### 6.4.1 입력 매개변수 수정을 피해야 하는 이유

- **문제점**: 함수가 전달받은 객체를 수정하면 호출한 쪽에서 예상치 못한 부수효과와 버그가 발생할 수 있으며 이는 마치 빌린 책에 낙서를 하거나 찢는 것과 유사하다.

### 6.4.2 해결책: 입력 매개변수 복사

- **대안**: 매개변수 수정을 피할 수 없다면 수정 전에 **복사본**을 만들어 사용하는 것이 좋다. 이로써 원본 객체는 유지된다.

- **성능 고려**: 매개변수 복사는 성능에 영향을 줄 수 있지만, 예기치 않은 동작이나 버그를 방지하는 이점이 더 클 수 있다. 대규모 데이터의 경우 성능을 위해 함수명과 문서에서 수정을 명확히 알리는 것이 필요하다.

## 6.5 오해를 일으키는 함수는 작성하지 말라

개발자가 어떤 함수를 호출하는 코드를 접하면 그들은 자신들이 보는 것에 기초하여 함수 내부에서 무슨 일이 일어나고 있는지에 대해 생각하며 명백한 부분이 누락되면 예기치 못한 결과를 초래할 수 있다.

그러나 더 좋지 않은 경우는 코드 계약의 명백한 부분에 오해의 소지가 있을 때다.  
`displayLegalDisclaimer()`라는 이름의 함수를 접한다면 이 함수의 호출 시 법적 고지 사항이 표시될 것이라고 가정할 것이다.

하지만 항상 그렇지만은 않다면, 이 함수로 인해 예상을 벗어나는 결과와 버그로 이어지기 쉽다.

### 6.5.1 중요한 입력이 누락되었을 때의 문제

- **문제점**: 함수에서 중요한 매개변수가 **누락되었을** 때 아무것도 하지 않도록 설계하면 **호출자**가 심각성을 인식하지 못하고, 다른 개발자가 코드를 읽을 때 이 함수가 항상 작업을 수행한다고 오해할 수 있다.

- **예시**: `displayLegalDisclaimer`는 법적 고지 사항을 화면에 표시하는데, 매개변수 `legalText`가 `null`일 경우 아무것도 표시하지 않고 종료한다. 이로 인해 함수 호출자가 중요성을 인지하지 못하고 법적 요구 사항을 누락할 위험이 있다.

### 6.5.2 해결책: 중요한 입력은 필수 항목으로 설정

- **핵심 매개변수는 null을 허용하지 않음**: 필수 매개변수에 대해 `null`을 허용하지 않으면 호출자는 직접 입력의 **무결성**을 확인하게 되고 오해의 여지를 줄이고 안정성을 높일 수 있다.

- **명확한 코드 작성의 이점**: 호출자에게 중요한 매개변수를 전달하지 않으면 문제가 발생할 수 있음을 분명히 하여, 코드가 잘못 해석되거나 기대와는 동작이 발생하는 바람을 줄인다.

## 6.6 미래를 대비한 열거형 처리

우리가 의존하는 코드에 대해 부실한 가정을 할 경우에도 우리의 예상을 벗어나는 결과를 초래할 수 있다.  
열거형(enum)에 대해서 개발자들 사이에 논쟁이 있다.

일부에서는 향 안전성을 제공하고 함수나 시스템에 유효하지 않은 입력을 방지할 수 있는 훌륭하고 간단한 방법이라고 주장한다.

다른 사람들은 열거형의 특정 값을 처리하기 위한 논리가 코드 전반에 퍼져 있게 되기 때문에 간결한 추상화 계층을 막는다고 주장하며 다형성(polymorphism)이 더 나은 방식이라고 주장한다.

어떤 값이 특정 클래스에서만 사용되면 그 클래스 내에 해당 값에 대한 정보와 동작을 캡슐화한 다음, 이 클래스를 넘어 공동 인터페이스를 구현하도록 하라는 것이 이 주장의 요지다.

열거형에 대한 개인적인 의견과 상관없이, 코드에서 열거형을 접하게 될 가능성이 있고 어느 시점에는 열거형을 다뤄야 할 가능성이 있다.

그 이유는 다음과 같다.

- 다른 사람의 코드의 결과를 사용해야 하며 어떤 이유로든 그들이 열거형을 즐겨 사용할 수 있다.
- 다른 시스템에서 제공하는 결과를 사용하고 있을 때 열거형을 중종 데이터 형식에서 유일하게 실용적인 옵션일 수 있다.

열거형을 처리해야 하는 경우 나중에 열거형에 더 많은 값이 추가될 수 있다는 점을 기억하는 것이 중요하다.

이것을 무시하고 코드를 작성하면, 자기 자신 혹은 다른 개발자들의 예측을 벗어나는 좋지 않은 결과를 초래할 수 있다.

### 6.6.1 열거형 값의 암묵적 처리 문제

- **문제점**: 열거형 값이 객체를 일부만 명시적으로 정의하고 나머지는 암묵적으로 처리할 경우, 향후 새로운 열거형 값이 추가되면 심각한 버그가 발생할 수 있다.

- **예시**: `isOutcomeSafe` 함수는 `COMPANY_WILL_GO_BUST`를 불안전한 결과로 명시적으로 처리하고, 나머지 열거형 값을 안전한 것으로 암묵적으로 처리한다. 그러나 이후 `WORLD_WILL_END` 값이 추가되면, 이 예측 결과에 대해서도 안전하다고 잘못 판단하여 시스템이 예기치 않은 동작을 할 수 있다.

### 6.6.2 해결책: 모든 열거형 값을 명시적으로 처리

- `switch` 문을 통해 명시적 처리: 모든 열거형 값을 `switch` 문으로 처리하여 새 열거형 값이 추가되면 오류가 발생하도록 한다. 이로써 누락된 값이 있으면 컴파일 시점 또는 테스트에서 즉시 오류가 발생하여 개발자가 해당 값을 추가로 처리해야 함을 인식할 수 있다.

### 6.6.3 기본 케이스 주의사항

- **기본 케이스 (default)**: `switch` 문에서 기본 케이스를 사용하여 처리되지 않은 열거형 값을 암시적으로 처리하면, 새 열거형 값이 추가될 때 버그가 발생할 수 있다.

- **기본 케이스에서 예외 처리**: 기본 케이스에서 예외를 발생하도록 변경하면 컴파일러가 경고하지 않으므로, 컴파일 후에 예외 처리를 `switch` 문 뒤에 두는 것이 더 안전할 수 있다.

### 6.6.4 외부 열거형 값 의존성 문제

- **의존성 위험**: 외부 프로젝트의 열거형에 의존할 경우, 예기치 않은 열거형 값이 추가되어 코드가 오작동할 가능성이 있다.

- **대처 방안**: 외부 열거형 값 추가에 대한 예상이 어려운 경우, 코드를 유연하게 처리하거나 적절한 예외 처리를 통해 보호하는 것이 필요하다.

## 6.7 테스트로 모든걸 해결가능 한가?

예상을 벗어나는 코드를 방지하기 위해 테스트로 모든걸 잡아낼 수 있어 이러한 노력은 시간낭비라고 주장하는 사람들이 많다. 하지만 다소 이상적인 주장이며 **테스트만으로는** 충분하지 않다.

- **테스트 성실성 부족**

  - 모든 개발자가 테스트 시 다양한 시나리오와 코너 케이스를 충분히 고려하지는 않는다. 특히, 특정한 상황이나 큰 입력값에 대한 문제는 제대로 테스트되지 않을 수 있다.

- **실제 상황과 테스트 간의 차이**

  - 테스트 환경에서 목(mock) 객체를 사용하다 보면 실제 상황과 일치하지 않을 수 있다. 목 객체가 실제 코드의 동작과 다르게 설정된다면, 중요한 버그가 테스트에서 발견되지 않을 수 있다.

- **테스트하기 어려운 문제**
  - 멀티스레드 환경에서의 부수 효과와 같은 문제는 낮은 확률로 발생하거나 대규모 환경에서만 나타날 수 있어, 테스트로 잡아내기 어렵다.
