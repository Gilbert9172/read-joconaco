# CHAPTER 5 가독성 높은 코드를 작성하라 25

- 코드가 이해하기 어려우면 다른 개발자들(그리고 미래의 자신도) 코드를 오해할 수 있고, 의도치 않게 오류가 있는 코드를 추가할 수 있다.
  <br>

## 5.1 서술형 명칭 사용

이름은 사람을 고유하게 식별하기 위해 필요하지만 무엇인지에 대해 간단한 설명을 할 때도 많다.

예제: 토스터기는 단어로 인해 "무언가 굽는 것"이라는 것을 알 수 있다.

코드에서 이름을 지을 때도 같은 원리가 적용되며 클래스, 함수, 변수와 같은 것들을 고유하게 식별하기 위해 이름이 필요하다.

이름을 붙이는 것은 그것이 스스로 설명되는 방식으로 언급함으로써 읽기 쉬운 코드 작성을 위한 기회이기도 하다.

### 5.1.1 서술적이지 않은 이름은 코드 이해를 어렵게 만든다

서술적이지 않은 이름을 사용할 경우, 코드를 읽는 개발자는 해당 코드의 목적을 이해하는 데 어려움을 겪게 된다.

예제 코드 5.1과 같이, 짧은 시간 안에 코드가 무엇을 하는지 파악하기 어려운 경우가 많다.

### 5.1.2 주석으로 서술적 이름을 대신할 수 없다

주석을 통해 변수와 함수의 역할을 설명할 수는 있지만, 코드의 이해를 크게 돕지 못한다.

주석이 많아질수록 코드가 복잡해 보이고, 주석과 코드 유지 보수 작업이 따로 필요하게 된다.

또한 주석으로 설명된 내용은 코드의 구조를 바꾸지 않음으로 서술적 이름을 사용하는 것보다 가독성이 떨어진다.

### 5.1.3 해결책: 서술적인 이름 짓기

서술적인 이름을 사용하면 코드의 의미가 명확해져 별도의 설명 없이도 쉽게 이해할 수 있다.

예제 코드 5.3과 같이 **Team**, **containsPlayer**, **getScore** 같은 서술적 이름을 사용하여, 코드의 가독성이 크게 향상시킬 수 있다.

이제 코드를 설명할 주석이 없어도 코드만으로도 의도를 파악할 수 있게 된다.

서술적인 이름의 장점:

- 코드가 더 간결하고 이해하기 쉬워진다.
- 주석을 관리할 필요가 없어 개발자는 코드에 집중할 수 있다.

<br>

## 5.2 주석문의 적절한 사용

코드 내에서 **주석문**이나 문서는 다음과 같은 두 가지 주요 목적을 수행한다.

- 코드가 무엇을 하는지 설명
- 코드가 왜 그 일을 하는지 설명

**클래스**와 같이 큰 단위의 코드가 무엇을 하는지 요약하는 높은 수준에서의 주석문은 유용하다.

그러나 세부 수준에서 한 줄 한 줄 코드가 무엇을 하는지 설명하는 주석문은 가독성을 높이기 위한 효과적인 방법이 아니다.

**[상식의 사용]**

주석문의 사용 방법과 시기에 대한 일반적인 지침을 제공하지만 이것이 반드시 따라야 할 엄격한 규칙은 아니며 상식적으로 생각하여 적용하면된다.

어렵고 복잡한 비트 논리를 쓸 수밖에 없거나, 코드를 최적화하기 위해 몇 가지 반복되는 트릭을 반드시 사용해야 한다면, 낮은 층위에서 코드가 무엇을 하는지 설명하는 주석문이 유용하다.

### 5.2.1 불필요한 주석은 해로울 수 있다

- 코드가 이미 그 자체로 설명이 가능한 경우, 불필요한 주석은 오히려 가독성을 해친다.
- 예시: `firstName + "." + lastName` 코드는 이름과 성을 ID로 생성한다는 설명이 자명하므로, 주석을 추가할 필요가 없다.

- 불필요한 주석의 문제:
  - 유지보수가 필요하다: 코드를 수정할 때마다 주석도 수정해야 한다.
  - 코드가 지저분해진다: 주석이 많으면 코드와 주석을 동시에 읽어야 해 시간 낭비가 될 수 있다.

### 5.2.2 주석으로 가독성 높은 코드를 대체할 수 없다

- 주석이 필요한 경우는 코드를 명확하게 설명할 수 없는 상황이어야 한다.
- 예시: `data[0]`과 `data[1]`이 각각 이름과 성을 나타내는 코드에 주석을 추가하면 이해할 수 있지만, 대신 가독성 좋은 함수 (`firstName`, `lastName`)로 대체할 수 있다.

### 5.2.3 주석은 코드의 이유를 설명하는 데 유용하다

- 코드의 목적이나 이유는 코드 자체로는 설명하기 어려운 경우가 많다.
- 예시: 특정 버전 이전에 가입한 사용자의 ID 생성 로직에 주석을 추가해 변경된 이유를 설명한다.이는 다른 개발자가 혼란 없이 코드를 이해할 수 있도록 돕는다.

- 주석이 유용할 상황:
  - 제품/비즈니스의 의사결정
  - 버그 해결 설명
  - 의존하는 코드의 예상치 못한 동작 설명

### 5.2.4 상위 수준의 요약 정보를 제공하는 주석

- 높은 수준에서 코드가 무엇을 하는지 요약하는 주석은 유용하다.

- 예시: `User` 클래스에 상위 수준의 설명을 추가해 해당 클래스가 데이터베이스와 직접 연결되지 않음을 알리는 등 주요 정보를 전달한다.

- 상위 수준 주석의 유용성:
  - 클래스의 역할과 주요 세부 사항을 설명
  - 함수의 입력 매개변수, 반환 값 등을 설명

### 주석 사용 시 유의점

- 주석이 많으면 유지보수가 어려워지고, 코드와 맞지 않는 경우 혼란을 초래할 수 있다.
- 코드가 자명하게 작성될 수 있는 경우 주석보다 코드 자체로 의미를 전달하도록 작성하는 것이 바람직하다.

<br>

## 5.3 코드 줄 수를 고정하지 말라

일반적으로 코드베이스의 코드 줄 수는 적을수록 좋다.

하지만 코드는 일반적으로 어느 정도의 지속적인 유지보수를 필요로 하며 코드의 줄이 많은 것은 코드가 지나치게 복잡하거나, 기존 코드를 재사용하지 않고 있다는 신호일 수 있다.

정말로 신경 쓰는 것은 코드에 대해 다음과 같은 사항들을 확실하게 하는 것이다.

- 이해하기 쉽다.
- 오해하기 어렵다.
- 실수로 작동이 안 되게 만들기가 어렵다.

매우 이해하기 어려운 코드 한 줄은 같은 일을 하는 이해하기 쉬운 코드 10 줄(또는 심지어 20 줄)에 비해 코드 품질을 쉽게 낮출 수 있다.

### 5.3.1 간결하지만 이해하기 어려운 코드의 문제

- 코드가 짧을수록 가독성이 떨어질 수 있다. 특히, 많은 가정을 포함한 단 한 줄의 코드는 다른 개발자가 이해하기 어렵다.

- 예시: 패리티 비트를 검사하는 코드 (`isIdValid`)가 너무 간결해, 아래와 같은 가정을 이해하기 어렵게 한다:

  - ID의 하위 15비트에 값이 저장되어 있다.
  - 최상위 비트는 패리티 비트이다.
  - 15비트의 값이 짝수면 패리티 비트는 0, 홀수면 1이다.
  - `0x7FFF`와 `0x8000`는 각각 하위 15비트와 최상위 비트를 위한 비트 마스크이다.

- 이러한 문제로 인해:
  - 다른 개발자는 코드를 이해하기 위해 많은 노력을 기울여야 하고, 오해로 인해 코드 수정 시 오류가 발생할 가능성이 높다.
  - 패리티 비트 위치가 코드 전반에 일관되게 사용되지 않으면 문제를 일으킬 수 있어, 하나의 소스에서 이를 관리하는 것이 바람직하다.

### 5.3.2 해결책: 더 많은 줄로 가독성 높은 코드 작성

- 가독성을 위해 더 많은 코드 줄을 작성해도 좋다.

- 예시: 예제 5.10은 헬퍼 함수와 상수를 사용해 가독성을 높인 코드이다.
- 이 코드에서는 주요 상수와 헬퍼 함수를 명확하게 정의하여 코드의 각 부분이 무엇을 의미하는지 쉽게 이해할 수 있다.

  - `PARITY_BIT_INDEX`, `PARITY_BIT_MASK`, `VALUE_BIT_MASK`와 같은 상수를 정의하여 의미를 명확히 함.
  - `getIdValue`와 `extractEncodedParity` 함수를 통해 ID의 값과 패리티 비트를 추출.
  - `calculateParity` 함수로 짝수/홀수를 검사하여 패리티를 확인.

- 추가적인 코드가 더 많은 줄을 차지할 수 있지만, 가독성 향상 및 코드의 재사용성을 높일 수 있다.

<br>

## 5.4 일관된 코딩 스타일을 고수하라

문법적으로 올바른 문장을 쓰려면 지켜야 할 규칙들이 있으며 잘 읽히는 문장을 쓰기 위해 따라야 할 문제에 관한 지침들이 있어 코드 또한 마찬가지이다.

프로그래밍 언어의 구문과 컴파일되는 (문법 규칙처럼) 허용되는 것을 규정하지만 개발자가 코드를 작성할지 따라 어떤 스타일로 작성할지는 상당히 자유롭다.

### 5.4.1 일관되지 않은 코딩 스타일이 문제를 일으키는 사례

- 코드의 일관된 스타일은 코드의 가독성과 유지보수성에 큰 영향을 미친다.

- 예시: `GroupChat` 클래스에서 `connectionManager`는 일반적으로 인스턴스 변수라고 가정되지만, 사실은 클래스 이름으로, 이를 잘못 해석해 코드가 작동하지 않게 된다.

  - `connectionManager.terminateAll()`이 인스턴스 변수로 오인되어, 이 함수가 특정 인스턴스의 연결만 종료할 것이라 생각되지만, 실제로 모든 연결을 종료한다.

- **일관된 명명 규칙**을 지켜 `ConnectionManager`와 같은 클래스 이름을 PascalCase로 작성하면 이러한 혼동을 방지할 수 있다.

### 5.4.2 해결책: 스타일 가이드를 채택하고 따르기

- 코딩 스타일 가이드는 클래스, 변수, 함수의 이름뿐만 아니라 다음과 같은 측면을 포함한다:

  - 언어 기능 사용법
  - 코드 들여쓰기
  - 패키지 및 디렉터리 구조화
  - 코드 문서화 방법

- 팀의 스타일 가이드를 따르는 것:

  - 대부분의 조직은 코딩 스타일 가이드를 가지고 있어, 이를 이해하고 따르면 코드의 일관성이 높아진다.
  - 팀의 스타일 가이드가 없는 경우, Google의 스타일 가이드와 같은 공개된 가이드를 참고할 수 있다.

- **린터(Linter), 코드 포매터 사용**:
  - 린터는 스타일 가이드 위반, 오류, 나쁜 관행을 알려주는 도구로, 코드 품질을 빠르게 개선할 수 있는 방법이다.
  - 단, 린터는 문제를 잡는 데 도움이 되지만 처음부터 좋은 코드 작성 습관을 대체할 수는 없다.

<br>

## 5.5 깊이 중첩된 코드를 피하라

일반적으로 코드는 다음과 같이 서로 중첩되는 블록으로 구성된다.

- 함수가 호출되면 그 함수가 실행되는 코드는 하나의 블록이 된다.
- `if` 문이 조건이 참일 때 실행되는 코드는 하나의 블록이 된다.
- `for` 루프의 각 반복 시 실행되는 코드는 하나의 블록이 된다.

일반적으로 주어진 논리를 코드로 구성하는 방법은 여러 가지가 있으며 많은 코드 블록이 중첩된 형태가 있는가 하면, 중첩이 거의 없는 구조도 있다.

코드의 구조가 가독성에 어떤 영향을 미칠 수 있으며 코드의 구조가 가독성에 어떤 영향을 미칠지 고려하는 것이 중요하다.

### 5.5.1 깊이 중첩된 코드의 문제

- 여러 겹으로 중첩된 `if` 문은 코드의 가독성을 저하시킨다.
- 중첩이 깊어지면 특정 조건이 실행되는 시점을 파악하기 어렵고, 코드의 흐름을 따라가기 힘들어진다.
- 예시: 차량 소유자의 주소를 찾는 함수에서 여러 겹의 중첩된 `if` 문이 사용되어 코드 흐름을 추적하기 어려움.

### 5.5.2 해결책: 중첩을 최소화하기 위한 구조 변경

- 중첩된 `if` 문을 간단한 조건문으로 재배치하여 가독성을 높일 수 있다.
- 반환문을 각 조건에 추가하면 중첩이 줄어들고, 코드가 이해하기 쉬워진다.
- 예시: 중첩된 `if` 문을 구사하여 각 조건에서 바로 반환하게 함으로써 중첩을 제거한 코드.

### 5.5.3 중첩은 너무 많은 일을 하고 있다는 신호

- 함수가 지나치게 많은 작업을 수행하면 중첩된 논리 구조가 복잡해지기 쉽다.
- 예시: 차량 소유자의 주소를 찾고 편지를 보내는 작업이 하나의 함수에 포함된 경우, 중첩을 줄이기 어려움.
- 해결 방법: 함수를 분리하여 각 함수가 한 가지 역할만 수행하게 만드는 것이 좋다.

### 5.5.4 해결책: 더 작은 함수로 분리

- 각 기능을 작은 함수로 분리하면 중첩 없이 간결한 구조를 유지할 수 있다.
- 예시: `getOwnersAddress` 함수를 분리하여 `sendOwnerALetter` 함수는 단순히 주소를 얻고 편지를 보내는 역할만 하도록 개선.

<br>

## 5.6 함수 호출도 가독성이 있어야 한다

어떤 함수의 이름이 잘 명명되면 그 함수가 무슨 일을 하는지 분명하지만 이름이 잘 지어졌더라도 함수의 인수가 무엇을 위한 것이고, 무슨 역할을 하는지 명확하지 않다면 함수 호출 자체가 이해되지 않을 수 있다.

> **[NOTE] 많은 함수 인수**
> 함수 호출은 인수의 개수가 늘어나면 이해하기 힘들어진다.

함수나 생성자가 많은 수의 매개변수를 가지고 있으면 이것은 보다 근본적인 문제를 나타내는 것일 수 있다.

매개변수를 추상 계층을 적절히 정의하지 않았거나 코드가 충분히 모듈화되지 않았음을 의미할 수 있다.

### 5.6.1 매개변수가 이해하기 어려운 문제

- 코드에서 함수를 호출할 때 매개변수가 명확하지 않으면 가독성이 떨어진다.

- 예시: `sendMessage("hello", 1, true);` 에서 `"hello"`는 메시지로 추측 가능하지만, `1`과 `true`가 무엇을 의미하는지는 알기 어렵다.

- 매개변수가 의미하는 바를 알기 위해 함수 정의를 확인해야 하는데, 이 과정이 번거로워 가독성에 악영향을 미친다.

### 5.6.2 해결책: 명명된 매개변수 사용

- 일부 언어는 명명된 매개변수를 지원해 호출 시 매개변수의 이름을 함께 사용할 수 있다.

  - 예: `sendMessage(message: "hello", priority: 1, allowRetry: true);`

- 모든 언어가 명명된 매개변수를 지원하는 것은 아니므로, 객체 구조 분해와 같은 기법을 활용해 유사한 효과를 얻을 수 있다.

### 5.6.3 해결책: 서술적 유형 사용

- 명명된 매개변수 없이도 서술적인 유형을 정의하여 가독성을 개선할 수 있다.

  - 예: 우선순위를 나타내는 `MessagePriority` 클래스와, 재시도 정책을 정의한 `RetryPolicy` 열거형을 사용.
  - 호출 시 `sendMessage("hello", new MessagePriority(1), RetryPolicy.ALLOW_RETRY);`와 같이 읽기 쉬운 코드가 된다.

### 5.6.4 때로는 만족스러운 해결책이 없다

- 예시: `BoundingBox(int top, int right, int bottom, int left)`처럼 네 개의 정수 매개변수를 받는 생성자는 가독성이 떨어진다.

- 해결책이 마땅치 않으므로, 인라인 주석을 사용해 각 매개변수의 의미를 표시하는 방법을 사용할 수 있다.
  - 인라인 주석은 최신 상태를 유지하기 어려운 단점이 있으며, 잘못된 정보가 있을 경우 오히려 혼란을 줄 수 있다.

### 5.6.5 IDE의 도움

- 일부 IDE는 함수 호출 시 매개변수 이름을 표시해 주어 가독성을 돕는다.

  - 예: `sendMessage(message: "hello", priority: 1, allowRetry: true);`

- 그러나 모든 개발자가 이러한 기능이 있는 IDE를 사용하는 것은 아니므로, 코드 자체의 가독성을 높이는 것이 중요하다.

<br>

## 5.7 설명되지 않은 값을 사용하지 말라

하드 코드 작성된 값이 필요한 경우가 많이 있으며, 일반적인 예는 아래와 같다.

- 한 수량을 다른 수량으로 변환할 때 사용하는 계수
- 작업이 실패할 경우 재시도의 최대 횟수와 같이 조정 가능한 파라미터 값
- 어떤 값이 채워질 수 있는 템플릿을 나타내는 문자열

하드 코드로 작성된 모든 값에는 두 가지 중요한 정보가 있다.

- 값이 무엇인지: 컴퓨터가 코드를 실행할 때 이 값을 알아야 한다.
- 값이 무엇을 의미하는지: 개발자가 코드를 이해하려면 값의 의미를 알아야 하며 이 정보가 없으면 코드를 이해할 수 없다.

값이 없으면 컴파일되지 않거나 자동화되지 않기 때문에 존재해야한다.

하지만 그 값이 실제로 무엇을 의미하는지 다른 개발자들이 명확히 이해하도록 하는 것은 잊어버리기 쉽다.

### 5.7.1 설명되지 않은 값의 문제

- 코드에서 특정 값에 존재하는지 명확하지 않으면, 다른 개발자가 코드를 이해하기 어려워지고 오류가 발생할 가능성이 커진다.

- 예시: `getKineticEnergy()` 함수에서 `907.1847`과 `0.44704` 같은 값이 무엇을 의미하는지 설명이 없어 혼란을 초래한다.

### 5.7.2 해결책: 잘 명명된 상수 사용

- 상수를 정의하여 값을 설명할 수 있다. 상수 이름을 통해 값의 의미를 명확히 함으로써 코드 가독성을 높일 수 있다.

- 예시: `KILOGRAMS_PER_US_TON = 907.1847, METERS_PER_SECOND_PER_MPH = 0.44704`

### 5.7.3 해결책: 잘 명명된 함수 사용

- 공급자 함수와 헬퍼 함수를 활용하여 상수 대신 함수를 통해 값을 제공할 수 있다.

  - 공급자 함수: 값을 반환하는 함수로, 상수와 개념적으로 유사하지만 함수를 통해 값을 제공한다.

    - 예시: `kilogramsPerUsTon()`과 `metersPerSecondPerMph()` 함수를 정의하여 `getKineticEnergy()` 함수에서 호출.

  - 헬퍼 함수: 특정 변환 작업을 수행하는 함수로, 변환 로직을 함수로 분리하여 호출할 수 있다.
    - 예시: `usTonsToKilograms()`와 `mphToMetersPerSecond()` 함수를 정의하여 `getKineticEnergy()` 함수에서 호출.

<br>

## 5.8 익명 함수를 적절하게 사용하라

익명 함수는 이름이 없는 함수이며, 일반적으로 코드 내의 필요한 지점에서 임시로 정의된다.

간단하고 자명한 것에 익명 함수를 사용하면 코드의 가독성을 높여 주지만, 복잡하거나 자명하지 않은 것 혹은 재사용이 용이하는 데에 사용하면 문제가 될 수 있다.

> [함수형 프로그래밍]  
> 익명 함수와 매개변수에 함수를 사용하는 기법은 함수형 프로그래밍, 특히 람다 표현과 관련되어 있다.  
> 함수형 프로그래밍은 논리를 표현한 상태를 수정하지 않고 함수에 대한 호출이나 참조로 표현하는 패러다임이다.

### 5.8.1 익명 함수는 간단한 로직에 적합하다

- 익명 함수는 간단한 로직을 처리할 때, 이해하기 쉽고 코드 길이를 줄일 수 있어 유용하다.

- 예시: `getUsefulFeedback()` 함수에서
  거멘트가 비어있지 않은 피드백을 필터링할 때, 익명 함수 `feedback => !feedback.getComment().isEmpty()`는 간결하고 명확하다.

### 5.8.2 익명 함수의 가독성 문제

- 함수의 이름은 일반적으로 함수가 수행하는 일을 요약하여 코드 가독성을 높인다.

- 익명 함수는 이름이 없기 때문에, 복잡한 로직을 포함하는 경우 코드의 가독성을 떨어뜨릴 수 있다.

- 예시: 패리티 비트를 확인하는 익명 함수 `(id => countSetBits(id & 0x7FFF) % 2 == (id & 0x8000) >>> 15)`는 개발자가 쉽게 이해하기 어렵다.

### 5.8.3 해결책: 명명된 함수 사용

- 복잡한 **로직**이 필요한 경우, 익명 함수 대신 명명된 함수를 사용하는 것이 좋다.

- 예시: `isParityBitCorrect`라는 명명된 함수를 만들어 패리티 비트를 검증하는 논리를 포함하면, `getValidIds()` 함수의 가독성이 크게 향상된다.
  - 이로써 `getValidIds()` 함수는 높은 수준에서 논리를 명확히 전달할 수 있다.

### 5.8.4 익명 함수가 너무 길어질 때 문제

- 익명 함수가 길고 복잡해지면 가독성이 떨어진다.

- 긴 익명 함수는 중첩된 로직과 중첩된 들여쓰기가 생기기 때문에, 로직을 파악하기 어려워진다.

- 예시: `buildFeedbackListItems()` 함수에서 중첩된 익명 함수를 사용하여 피드백 목록을 표시하는 경우, 각 요소를 파악하기 어려워 가독성이 저하된다.

### 5.8.5 해결책: 긴 익명 함수를 여러 명명된 함수로 나누기

- 긴 익명 함수는 여러 개의 명명된 함수로 나누어 처리할 수 있다. 이로써 가독성과 모듈화를 개선할 수 있다.

- 예시: `buildFeedbackListItems()` 함수에서 `buildFeedbackItem`, `buildTitle`, `buildCommentText`, `buildCategories`와 같은 헬퍼 함수로 분리하여 각 요소의 역할이 명확해졌다.

<br>

## 5.9 프로그래밍 언어의 새로운 기능을 적절하게 사용하라

새로운 기능으로 인해 코드의 가독성이 높아지거나 코드가 더 견고해지는 경우가 많이 있을 수 있다.

하지만 프로그래밍 언어의 그런 새로운 기능을 사용하고 싶은 마음이 간절히 들 때, 그것이 정말로 그 일에 가장 적합한 도구인지 솔직하게 생각해봐야 한다.

### 5.9.1 새로운 기능이 코드 개선에 기여할 수 있다

- Java 8의 스트림(Stream) 기능은 함수형 스타일을 통해 코드의 간결성과 가독성을 높였다.

- 예시: 문자열 리스트에서 빈 문자열을 필터링하는 전통적인 Java 코드와 Stream을 사용한 코드를 비교하면, Stream을 사용한 코드가 더 간결하고 이해하기 쉽다.

```java
// 전통적인 Java 코드
List<String> getNonEmptyStrings(List<String> strings) {
   List<String> nonEmptyStrings = new ArrayList<>();
   for (String str : strings) {
       if (!str.isEmpty()) {
           nonEmptyStrings.add(str);
       }
   }
   return nonEmptyStrings;
}

// Stream을 사용한 코드
List<String> getNonEmptyStrings(List<String> strings) {
   return strings.stream()
                 .filter(str -> !str.isEmpty())
                 .collect(Collectors.toList());
}
```

- 새로운 기능을 잘 활용하면 코드가 더 최적화되고 효율적으로 개선될 수 있다. 언어에서 제공하는 기능을 적극적으로 활용하는 것이 코드 품질 개선에 유리하다.

### 5.9.2 불명확한 기능은 혼란을 초래할 수 있다

- 새로운 기능이 유용하더라도 모든 개발자가 해당 기능에 익숙하지 않다면 코드가 혼란을 초래할 수 있다.

- 예를 들어, Java Stream에 익숙하지 않은 팀에서는 기존 방식으로 작성하는 것이 유지보수에 유리할 수 있다.

- 따라서 새로운 기능의 사용으로 얻을 수 있는 장점이 적거나, 사용자가 그 기능에 익숙하지 않다면 차라리 기존 방식을 유지하는 것이 더 나을 수 있다.

### 5.9.3 작업에 적합한 도구 사용

- 새로운 기능이 강력하다고 해서 모든 상황에서 최선의 선택은 아니다.

- 예시: Map에서 특정 키의 값을 찾을 때, 가장 적절한 방법은 `map.get(key)`이다.
  - 아래처럼 Stream을 이용해 Map에서 키로 값을 찾는 방식은 가독성도 떨어지고, 비효율적이다.

```java
Optional<String> value = map.entrySet()
         .stream()
         .filter(entry -> entry.getKey().equals(key))
         .map(Map.Entry::getValue)
         .findFirst();
```

- 새로운 기능을 사용할 때는 단지 최신 기술이기 때문이 아니라, 해당 작업에 가장 적합한 도구로 선택하는 것이 중요하다.
